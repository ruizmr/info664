from typing import Any

# Import Stmt, IfStmt, ReturnStmt, Expr, Binary, Scale, Round, Const, Var, Pred from search module
from .search import Stmt, IfStmt, ReturnStmt, Expr, Binary, Scale, Round, Const, Var, Pred


def _render_expr(expr: Expr) -> str:
    if isinstance(expr, Const):
        return f"{expr.value}"
    if isinstance(expr, Var):
        return expr.name
    if isinstance(expr, Binary):
        if expr.op in {'+', '-'}:
            return f"({_render_expr(expr.left)} {expr.op} {_render_expr(expr.right)})"
        else:
            return f"{expr.op}({_render_expr(expr.left)}, {_render_expr(expr.right)})"
    if isinstance(expr, Scale):
        op_symbol = '*' if expr.op == '*' else '/'
        return f"({_render_expr(expr.expr)} {op_symbol} {expr.k})"
    if isinstance(expr, Round):
        return f"round({_render_expr(expr.expr)}, {expr.p})"
    raise TypeError(f"Unknown Expr type: {type(expr)}")


def _render_stmt(stmt: Stmt, level: int = 1) -> str:
    indent_str = '    ' * level
    if isinstance(stmt, ReturnStmt):
        return indent_str + f"return round({_render_expr(stmt.expr)}, 2)" + "\n"
    if isinstance(stmt, IfStmt):
        pred = stmt.pred
        pred_str = f"{_render_expr(pred.left)} {pred.op} {_render_expr(pred.right)}"
        res = indent_str + f"if {pred_str}:\n"
        res += _render_stmt(stmt.then_branch, level + 1)
        res += indent_str + "else:\n"
        res += _render_stmt(stmt.else_branch, level + 1)
        return res
    raise TypeError("Unsupported statement type")


def render_program(stmt: Stmt) -> str:
    """Render the full legacy_reimburse function as Python code string."""
    body_code = _render_stmt(stmt, level=1)
    template = (
        "def legacy_reimburse(d: int, m: int, r: float) -> float:\n"
        "    \"\"\"Deterministic reimplementation generated by synthesis.\n"
        "    Inputs:\n"
        "        d -- trip duration days\n"
        "        m -- miles traveled\n"
        "        r -- total receipts amount\n"
        "    Returns float rounded to 2 decimal places.\n"
        "    \"\"\"\n"
        f"{body_code}"
        "\n"
        "    # Ensure 2-decimal output\n"
        "    return round(_result, 2)\n"
    )
    # For easier insertion of return, we modify above: Instead of directly returning values, we store to _result.
    # We'll rewrite body to assign _result variable; adjusting.
    # For now, simpler: assume last line returns.
    # We'll just wrap body and rely on its return.
    # So adjust function to not double wrap.

    func_code = (
        "def legacy_reimburse(d: int, m: int, r: float) -> float:\n"
        "    \"\"\"Deterministic reimbursement model (synthesised).\n"
        "    \"\"\"\n"
        + body_code +
        "\n"
    )
    return func_code


def write_program(stmt: Stmt, path: str = "legacy_reimburse.py") -> None:
    code = render_program(stmt)
    with open(path, "w") as f:
        f.write(code)